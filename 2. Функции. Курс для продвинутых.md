# Позиционные и именованные аргументы
## Содержание
- позиционные аргументы
- именованные аргументы
- необязательные аргументы
- изменяемый тип данных в аргументах по умолчанию (сложно)
## Позиционированные аргументы
раньше мы писали (например) 2 параметра, 2 аргумента и они логичным образом сопоставлялись. 1 к 1, 2 ко 2
``` python
def diff(x, y):
	return x - y

res = diff(10, 3)
print(res)

>>> 7
```
здесь логично выходит, что параметры x и y соответственно равны 10 и 3, все очень просто
это был пример ==позиционированных аргументов==, но в python есть и ==именованные аргументы==

## Именованные аргументы
аргументы, что будут передаваться в параметры вместе с именами - называются именованными. можно использовать названия аргументов из параметров функции
исключением здесь составляют списки аргументов неопределенной длины, где используются аргументы со звездочкой (пока хз)
``` python
def diff(x,y):
	return x - y

res = diff(x=10, y = 3)
# или же
res = diff(y = 3, x=10)
print(res)

>>> 7
```
мы явно указали, чему будут равны параметры функции. это позволяет нарушать позиционный порядок аргументов при вызове функции
это еще один повод использовать осмысленные имена переменных, ведь они могут быть использованы для именованных аргументов
## Когда стоит применять именованные аргументы?
строгих правил нет, но если используются более трех аргументов, нужно хотя бы часть указать по имени, ведь при нескольких аргументов одного типа могут быть сложности с пониманием
``` python
# прмиер
def make_circle(x, y, radius, line_width, fill):
	# тело функции

make_circle(200, 300, 17, 2.5, True)
```
тут легко запутаться, что есть 200, 300 и 17
```python
# сравним:
make_circle(x=200, y=300, radius=17, line_width=2.5, fill=True)
```
тут все гораздо понятнее, читать легче и приятнее

по PEP8 в именованных аргументах пробелы не используются

если значение именованных аргументов очевидно - можно их не использовать
``` python
point3d(1, 2, 3)
rgb(7, 255, 255)
# здесь очевидно: координаты в 3д, цвета red, green, blue. доп пояснений не требуется
```
уже использовали именованные аргументы, когда пользовались `print()`. речь про `sep=''` и `end=''`.  их можно указывать в произвольном порядке

## Комбинирование позиционных и именованных аргументов
можно использовать оба типа аргументов одновременно. однако позиционные должны быть указаны ==до== любых именованных. `позицонные, именованные`
```python
def diff(x,y):
	return x - y

res1 = diff(10, y=3)
res2 = diff(x=10, 3)  # ошибка, сначала позиц, потом именованный

print(res1)
print(res2)

>>> 7
>>> SyntaxError: positional argument follows keyword argument
```
## Необязательные параметры
иногда параметры принимают одно значение, которое установили по умолчанию. у `sep=' '` и  `end='\n'` - пробел и перевод строки соответственно
`int()` - принимает 2 аргумента: строку, что нужно перевести в число, основание СС (системы счисления)
``` python
num = int('101', 2)  # число 101 записано в двоичной СС
print(num)
>>> 5  # 101_2 = 5_10. 101 в двоичной равно 5 в десятичной
```
чаще всего работаем в десятичной, а каждый раз писать "10" вторым аргументом было бы утомительно, потому он указан по умолчанию. в таких случаях указанный по умолчанию параметр можно не указывать, он подставляется автоматом

чтобы задать значение по умолчанию, достаточно в списке параметров функции после имени переменной написать знак равно со значением
``` python
def make_circle(x, y, radius, line_width=1, fill=True):
    # тело функции

make_circle(100, 50, 20)
# или
make_circle(x=100, y=50, radius=20)
# значение параметра line_width и fill будет подставлено автоматом. 1 и True соответственно 

make_circle(x=100, y=50, radius=20, line_width=5, fill=False) 
# line_width=5, fill=False
```
==важно!==. параметры со значением по умолчанию идут в конце. если явно указать в аргументах отличное от значения по умолчания значение, то просто делаем это, как в примере 3 выше
получается некоторый промежуточный итог:
сначала указываются позиционные, потом именованные, и лишь в самом конце со значением по умолчанию
==`позиционные, именованные, по умолчанию`==

уж не знаю зачем, но вдруг однажды забуду, да и картинка красивая
![[9lg1H.png]]

## Изменяемые типы в качестве значений по умолчанию (сложный раздел)
а вот если использовать в кач значений по умолчанию изменяемые типы данных (список, например), то могут быть неожиданные результаты
```python
def append(element, seq=[]):
	seq.append(element)
	return seq

print(append(10, [1, 2, 3]))
print(append(5, [1]))
print(append(1, []))
print(append(3, [4, 5]))

>>> [1, 2, 3, 10]
>>> [1, 5]
>>> [1]
>>> [4, 5, 3]

print(append(10))
print(append(5))
print(append(1))

>>> [10]
>>> [10, 5]
>>> [10, 5, 1]
```
список - изменяемый тип данных, потому, при разовом изменении его значения, это значение будет тянуться каждое следующее использование функции. при каждом вызове будет подтягиваться предыдущий результат
такое, если честно : /

чтобы глянуть значение по умолчанию, можно использовать атрибут ______defaults______
``` python
def append(element, seq=[]):
	sq.append(element)
	return seq
	
print('значение по умолчанию', append.__defaults__)
print(append(10))
print('значение по умолчанию', append.__defaults__)
print(append(5))
print('значение по умолчанию', append.__defaults__)
print(append(1))
print('значение по умолчанию', append.__defaults__)
>>> Значение по умолчанию ([],)
>>> [10]
>>> Значение по умолчанию ([10],)
>>> [10, 5]
>>> Значение по умолчанию ([10, 5],)
>>> [10, 5, 1]
>>> Значение по умолчанию ([10, 5, 1],)
```
момент сложный, я считаю. это каждый раз отслеживать и держать в голове не очень круто

чтобы решить проблему можно использовать константу `None` в качестве значения для умолчания
```python
def append(element, seq=None):
    if seq is None:
        seq = []
    seq.append(element)
    return seq

print(append(10))
print(append(5))
print(append(1))

>>> [10]
>>> [5]
>>> [1]
```
этот подход, основанный на значении None считается в пайтон общепринятым

## Примечания
1. наиболее важные параметры указываются первыми
2. именованные аргументы часто используют вместо со значениями по умолчанию
3. параметры - один раз настраиваются и с ними работают, как в игре или программе, аргументы - как в математике. аргументы функции sin(x) - это x, то, что приняла функция
	1. *P*arameter -> *P*laceholder (заполнитель принадлежит имени функции и используется в теле функции);
	2. *A*rgument -> *A*ctual value (фактическое значение, которое передается при вызове функции).
# Функции с переменным количеством аргументов

## Содержание
- аргументы `*args`
- аргументы `**kwargs`
- keyword-only аргументы
## Переменное кол-во аргументов
рассмотрим функцию `print()`
```python
print('a')
print('a', 'b')
print('a', 'b', 'c')
print('a', 'b', 'c', 'd')

>>> a
>>> a b
>>> a b c
>>> a b c d
```
функция `print()` принимает любое число аргументов, сколько ей передано. даже без аргументов она работает - просто переносит строку
для создания функции с произвольным числом аргументов нужно изучить простой синтаксис
``` python
def my_func(*args):
	print(type(args))
	print(args)

my_func()
my_func(1, 2, 3)
my_func('a', 'b')

>>> <class 'tuple'>
>>> ()
>>> <class 'tuple'>
>>> (1, 2, 3)
>>> <class 'tuple'>
>>> ('a', 'b')
```
в параметрах функции мы передали всего 1 параметр со звездочкой. звездочка означает, что функция получит все аргументы в виде кортежа, что были переданы в функцию

можно использовать лишь один параметр помеченный звездочкой, причем располагаться он должен в конце, ведь он забирает себе все аргументы от текущего и до конца
```python
def my_func(num, *args):
    print(args)
    print(num)


my_func(17, 'Python', 2, 'C#')

>>> ('Python', 2, 'C#')
>>> 17
```
даже если у нас не будет аргументов для args, то все будет нормально. но для позиционных аргументов важно передать значение
```python
def my_func(num, *args):
    print(args)
    print(num)


my_func(17)

>>> ()
>>> 17
```
хотя функция и принимает несколько аргументов, хотя бы один точно должен быть введен для позиционного аргумента
> Параметр `args` в определении функции пишется после позиционных параметров перед первым параметром со значением по умолчанию.

## Передача аргументов в форме списка и кортежа
иногда нужно сначала сформировать набор аргументов, а потом передать их в функции (хз). тут поможет оператор распаковки коллекций - *
пример: `sum()` - принимает коллекцию чисел (в списке, кортеже, и тд)
она (на удивление) не работает просто с числами, ей реально необходимы именно коллекции
```python
sum1 = sum([1,2,3])
sum2 = sum(1,2,3)

print(sum1)
print(sum2)

>>> 6
>>> TypeError: sum expected at most 2 arguments, got 4
```
напишем свою функцию, что не будет вызывать ошибок при подобных действиях
``` python
def my_sum(*args):
	return sum(args)  # args - кортеж(tuple)

print(my_sum(1,2,3))

>>> 6
```
а также мы можем передавать ей и коллекции, распаковав их
``` python
print(*[1,2,3])
print(*(4,5,6))

>>> 6
>>> 15

# или можно даже так
print(my_sum(1, 2, 3, *[4, 5, 6], *(7, 8)))

>>> 36
```
вообще, этот параметр можно называть как угодно, но есть общее соглашение о том, чтобы он назывался именно так. args = arguments

## Получение именованных аргументов в виде словаря
`*args` - получение позиционных аргументов в любом кол-ве
аналогично можно сделать и для именованных аргументов
именованные аргументы получают в виде словаря, что позволяет сохранить имена аргументов в ключах
``` python
def func(**kwargs):
	print(type(kwargs))
	print(kwargs)

func()
func(a=1, b=2)
func(name='Tema', job='student')

>>> <class 'dict'>
>>> {}
>>> <class 'dict'>
>>> {'a': 1, 'b': 2}
>>> <class 'dict'>
>>> {'name': 'Timur', 'job': 'Teacher'}
```
по соглашению, такой параметр принято называть `kwargs` - keword arguments. словари. гениально!
`**kwargs` пишется в самом конце, после последнего аргумента со значением по умолчанию
функция может содержать как `*args`, так и `**kwargs` параметры

отличная демонстрация функционала аргов и кваргов
``` python
def func(a, b, *args, name='Gvido', age=17, **kwargs):
	print(a, b)
	print(args)
	print(name, age)
	print(kwargs)


my_func(1, 2, 3, 4, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, 3, 4, job='Teacher', language='Python')

>>> 1 2
>>> (3, 4)
>>> Timur 28
>>> {'job': 'Teacher', 'language': 'Python'}

>>> 1 2
>>> ()
>>> Timur 28
>>> {'job': 'Teacher', 'language': 'Python'}

>>> 1 2
>>> (3, 4)
>>> Gvido 17
>>> {'job': 'Teacher', 'language': 'Python'}
```
на самом деле, на практике редко используется все и сразу, но уметь в этом ориентироваться нужно
может выглядеть запарно, но на практике все нетрудно. главное запомнить позиционку

## Передача именованных аргументов в форме словаря
мы также как и с позиционными можем поступить с именованными: передать целую пачку. для этого перед `kwargs` пишем 2 звездочки **
``` python
def func(**kwargs):
	print(type(kwargs))
	print(kwargs)

info = {'name':'tema', 'job':'student', 'age':20}
func(**info)
# это нужно понять/принять

>>> <class 'dict'>
>>> {'name': 'tema', 'job': 'student', 'age': 20}
```

немного в сторону простого:
``` python
# просто демонстрация совместной работы *args и **kwargs
def print_info(name, surname, age, city, *children, **additional_info):
    print('Имя:', name)
    print('Фамилия:', surname)
    print('Возраст:', age)
    print('Город проживания:', city)
    if len(children) > 0:
        print('Дети:', ', '.join(children))
    if len(additional_info) > 0:
        print(additional_info)


children = ['Бодхи Рансом Грин', 'Ноа Шэннон Грин', 'Джорни Ривер Грин']
additional_info = {'height':163, 'job':'actress'}

print_info('Меган', 'Фокс', 34, 'Ок-Ридж', *children, **additional_info)

>>> Имя: Меган
>>> Фамилия: Фокс
>>> Возраст: 34
>>> Город проживания: Ок-Ридж
>>> Дети: Бодхи Рансом Грин, Ноа Шэннон Грин, Джорни Ривер Грин
>>> {'height': 163, 'job': 'actress'}
```
насколько я понимаю, `*args` и `**kwargs` можно писать вперемешку с именованными и позиционными. лишь бы все именованные шли после всех позиционных

## Keyword-only аргументы
в Python3 добавили такую фичу, что больше нельзя добавлять некоторые аргументы позиционным методом, а только явно указав их имена. это называется keyword-only
рассмотрим пример
``` python
def make_circle(x, y, radius, *, line_width=1, fill=True):
	# func_body
```
`*` - четкий разделитель обычных аргументов (можно указывать как по имени, так и позиционно) от строго именованных
тут понятно, что `x, y, radius` - обычные аргументы, а `line_wwidth, fill` - строго именованные
такой подход хорошо демонстрирует подход к описанию аргументов. первые три - коорды центра и радиус. они есть всегда, потому они могут быть не проименоваными.   
а вот `line_width, fill` - необязательные аргументы, получающие несовсем очевидные значения. для ясности их называния указываются явно
для ВСЕХ строго именованных аргументов нужно просто поставить `*` перед всеми аргументами
```python
def make_circle(*, x, y, radius, line_width=1, fill=True)
```
теперь необходимо явно указывать названия аргументов для вызова функции
такое нельзя использовать вместе с неогр числом позиционных аргументов (`*args`)

## Примечания
имена `*args` и `**kwargs` можно менять, но это не принято
1. позиционные аргументы
2. позиционные по умолчанию
3. `*args`
4. именованные
5. именованные по умолчанию
6. `**kwargs`

внимательно глянь здесь
```python
def func(a, b=2, *args, c, d=5 **kwargs):
	# func_body
func(1, 'b - умолч', '3', c=4, 'd - умолч', e=6)

>>> 1, 2, (3), 4, 5, {'f':6}
```
![[Pasted image 20250815100313.png]]

`*args` - собирает позиционные аргументы в кортеж. получает любое число аргументов
`**kwargs` - собирает именованные аргументы в словарь. ключ - имя, значение - значение именованного аргумента. получает любое число аргументов
keyword-only аргументы - аргументы, что передаются лишь по имени. для разделения только именованных и только позиционных используют символ `*` как разделитель. слева  позиционные или именованные, справа только именованные
# Парадигмы программирования

это подход к программированию. совокупность идей и понятий, определяющих стиль написания программ
она определяется:
- вычислительной моделью
- базовой программной единицей/единицами
- методами разделения абстракций
ЯП не обязательно использует только одну парадигму. существуют мультипарадигменные языки. пример: пайтон

основные парадигмы программирования:
- императивное
- структурное
- ооп
- функциональное
- логическое
первые япы были в парадигме императивного программирования, тк нужны были для решения математических задач

## Императивное программирование
ИП характеризуется тем, что:
- в исходном коде проги записаны инструкции(команды)
- инструкции должны выполняться последовательно
- данные, полученные при выполнении инструкции могут быть записаны в память
- данные, получаемые при выполнении предыдущих команд, могут читаться из памяти последующими инструкциями
ИП похожа на приказы (imperative - приказ)
здесь широко используется присваивание, но оно же увеличивает сложность программы и создает условие для специфических ошибок императивных программ

основные механизмы:
- последовательное исполнение программ
- использование именованных переменных
- использование операторов присваивания
- использование ветвления (if-elif-else)
- использование безусловного перехода (оператор goto)
ключевая идея ИП - работа с переменными, как с временным хранениям данных в оперативной памяти

## Структурное программирование
СП  нацелена на сокращение времени разработки и упрощение поддержки программ засчет использования блочного оператора и подпрограмм
отличительная черта - отказ от оператора безусловного перехода goto, который широко использовался в 1970-ых

основные механизмы управления:
- последовательное исполнение команд
- использование именованных переменных
- использование оператора присваивания
- использование ветвления
- использование циклов
- использование подпрограмм(функций)
в СП программа, по возможности, разбивается на мелкие функции(подпрограммы) с изолированным контекстом
## ООП
прога разбивается на объекты - структуры данных, состоящие из полей, описывающих состояние, и методов - функций, применяемых к объектам для изменения или запроса их состояния
ооп поддерживают наверное все современные япы
основные механизмы управления:
-  абстракиця
- класс
- объект
- полиморфизм
- инкапсуляция
- наследование

## Логическое программирование
прога использует описание проблемы в терминах фактов и логических формул, а решение находится через механизмы логического вывода
в 60-70-80-ых годах было популярно. был создан ЯП Prolog. здесь можно выделить выскоий уровень машинной независимости, возможность откатов, возвращения к предыдущей подцепи при отрицательном результате анализа одного из вариантов решения. 
недостаток: слишком специфический класс задач для решения, сложность эффективной реализации в режиме реального времени

## Функциональное программирование
ФП - основной инструмент мат функции
выражается связь между входящими данными и их итогами
имеется вход и выход, потому такое использование вполне применимо
ФП - декларативная парадигма программирования
функциональная программа - это набор определений функции. 
функции определяются через другие функции или через самих себя рекурсивно
при выполнении программы функции получают аргументы, вычисляют и возвращают результат.
тут сложный абзац, просто вставлю скрин
![[Pasted image 20250815172225.png]]
сильные стороны функционального программирования:
- надежность кода
- удобство организации модульного тестирования
- возможность оптимизации при компиляции
- возможность параллелизма

недостатки:
- отсутствие присваиваний, постоянное переприсваивание, что засоряет память. надо очищать
основные идеи:
- неизменяемые переменные. можно определить переменную, но изменить ее нельзя
- чистая функция - максимально предсказуемая функция. говорят, что подобные функции не вызывают побочных эффектов
- функции высшего порядка - могут принимать другие функции в качестве аргумента и возвращать их
- рекурсия - для ФП обязательна. поддерживается большинством ЯПов. в языках ФП нет циклов, но есть рекурсии для повторов. испольщование рекурсии в ФП оптимизировано и происходит быстрее, чем в языках ИП
- лямбда-выражения - способ определения анонимных функциональных объектов
## Примечания
- в основе ИП, СП, ООП лежит машина Тьюринга
- в основе ФП лежит модель лямбда-исчислений
![[Pasted image 20250815174006.png]]

# Функции как объекты
## Содержание
1. Функции как объекты (переименовка функций)
2. Функции в качестве аргументов других функций
3. Встроенные функции, принимающие функции в качестве аргументов (необязательный аргумент key)
4. Функции в качестве возвращаемых значений других функций (так себе, не оч понятно)
5. Примечания
## Функции как объекты
есть разные типы объектов: числа, строки, кортежи, массивы,..., и функции
у каждого объекта свои операции, свой синтаксис, но все это объекты
```python
num = 17
numbers = [1, 2, 3]
colors = (1, 2, 3)
name = 'Python'

print(type(num))
print(type(numbers))
print(type(colors))
print(type(name))

>>> <class 'int'>
>>> <class 'list'>
>>> <class 'tuple'>
>>> <class 'str'>
```
а любая функция будет иметь тип function
```python
print(type(print))
print(type(sum))
print(type(abs))

# builtin = встроенная функция
>>> <class 'builtin_function_or_method'>
>>> <class 'builtin_function_or_method'>
>>> <class 'builtin_function_or_method'>
```
важно, что скобки не ставим, тк мы не вызываем функцию, а передаем ее название в функцию `type()`
если мы объявим свою функцию, то вернет тип function
```python
def hello():
    print('Hello from function')


print(type(hello))

>>> <class 'function'>
```
в пайтоне объектом является вообще все
объекты можно записывать в переменные, передавать в качестве аргументов другим функциям, возвращать из функций
```python
def hello():
    print("'Hello from function'")


func = hello     #  присваиваем переменной func функцию hello
func()           #  вызываем функцию

>>> 'Hello from function'
```
теперь `func` можно использовать как функцию `hello()`
т.е можно переименовать название любой функции по своему усмотрению. 
если нам не нравится название функции `print()`, то мы можем переименовать ее на манер паскаля, например
``` python
writeln = print
writeln('Hi')

>>> Hi
```
допустим, нам нужно сделать такую штуку, что при команде `start` будет вызвана функция `start()`, пауза и стоп по аналогии. можно этого легко сделать так:
```python
def start():
	# тело функции
	pass

def pause():
	# тело функции
	pass

def stop():
	# тело функции
	pass


command = input()

if command == 'start':
	start()
elif command == 'pause':
	pause()
elif command == 'stop':
	stop()
```
но такое решение прям такое, т.к команд может быть много, оператор `if` может получиться громоздким
тогда используют словарь, где ключ - название команды, значение - соотв функция
вот более оптимальное решение
```python
commands = {'start': start, 'stop': stop, 'pause': pause}  # словарь соответствия команда → функция

command = input()  # считываем название команды

commands[command]()  # вызываем нужную функцию через словарь по ключу (синтаксис работы со словарями, пока хз)
```
вся логика обработчика команды сводится к простой строке `commands[command]()`
`command` - имя команды, которую нужно выполнить. такой код намного гибче 
```python
def f(x):
    return x**2


def g(x):
    return x**3


funcs = [f, g]
print(funcs[0](5), funcs[1](5))

>>> 25 125
```
## Функции в качестве аргументов других функций
из-за того, что мы можем присвоить название функции какой-то переменной, ее можно передать в качестве аргумента другой функции. доступно такое много где, но в пайтоне проще из-за гибкой типизации
можно рассмотраивать любую математическую функцию, как аргумент для функции `plot()` при построении графика, а так же a и b - границы графика
`def plot(func, a, b):`
если мы зададим некую функцию `square_add_one`, то сможем ее передать в качестве аргумента функции выше
```python
def plot(func, a, b):
	# тело функции
	pass

def square_add_one(x):
	return x**2 + 1

plot(square_add_one, 1, 10)

>>> построит график функции в границах от 1 до 10
```
![[Pasted image 20250818100641.png]]
естественно, необходимо оформить функцию `plot()`, ведь пока что она ничего не возвращает
функции, что способны в качестве аргумента принимать/возвращать другие функции, называются ==функциями высшего порядка==
## Встроенные функции, принимающие функции в качестве аргументов
в прошлых уроках мы изучили много встроенных функций типа min. max, sorted и тп
важно не путать метод `.sort()` с встроенной функцией `sorted()`. 
работают одинаково, но списочный метод `.sort()` сортирует список на месте, а функция `sorted()` возвращает новый, отсортированный список

демонстрировать работы базовых функций считаю излишним
но что если хотим написать код для поиска максимального по модулю числа? или любой другой специфический подход? 
в таком случае встроенные функции могут принимать необязательный аргумент `key` - функцию, определяющую условия сравнения объектов. иными словами: значение `key` должно быть функцией, принимающей 1 аргумент и возвращающий на его основе ключ для сравнения
функция для определения сравнения эл-тов называется компаратор (compare - сравнивать)
встроенные функции min, max, sorted - функции высшего порядка, т.к принимают в качестве аргумента функцию сравнения эл-тов
```python
numbers = [10, -7, 8, -100, -50, 32, 87, 117, -210]

print(max(numbers, key=abs))    #  указываем функцию abs в качестве компаратора
print(min(numbers, key=abs))    #  указываем функцию abs в качестве компаратора
print(sorted(numbers, key=abs))    #  указываем функцию abs в качестве компаратора

>>> -210
>>> -7
>>> [-7, 8, 10, 32, -50, 87, -100, 117, -210] # сортировка на основании модулей элементов
```
рассмотрим еще пример:
```python
def compare_by_second(point):
    return point[1]


def compare_by_sum(point):
    return point[0] + point[1]


points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]

print(sorted(points, key=compare_by_second))   # сортируем по второму значению кортежа
print(sorted(points, key=compare_by_sum))      # сортируем по сумме кортежа

>>> [(2, -4), (1, -1), (2, 3), (1, 5), (10, 9), (-10, 15), (7, 18)]
>>> [(2, -4), (1, -1), (2, 3), (-10, 15), (1, 5), (10, 9), (7, 18)]
```
круто!
![[Pasted image 20250818103952.png]]
```python
s1 = 'python'
s2 = 'stepicon'
s3 = 'beegeek'
 
print(min(s1, s2, s3))
print(max(s1, s2, s3))

>>> beegeek   
>>> stepicon

s1 = 'python'
s2 = 'stepicon'
s3 = 'beegeek'
 
print(min(s1, s2, s3, key=len))
print(max(s1, s2, s3, key=len))

>>> python   
>>> stepicon
```

```python
def comparator(pair):
    return pair[1]


pairs = [(5, 4), (3, 2), (1, 7), (8, 2)]
pairs.sort(key=comparator)
print(pairs)
```

```python
def comparator(pair):
    return pair[0] + pair[1]


pairs = [(5, 4), (3, 2), (1, 7), (8, 2)]
pairs.sort(key=comparator, reverse=True)
print(pairs)
```

```python
words = ['this', 'is', 'a', 'test', 'of', 'sorting']
words.sort(key=len)
print(words)
```
## Функции в качестве возвращаемых значений других функций
т.к функции - объекты, их можно передавать в другие функции как аргументы. функции могут быть результатом других функций, что позволяет писать генераторы функций, возвращающие функции в зависимости от подаваемого аргумента
рассмотрим пример, а то непонятно
```python
def generator():
	def hello():
		print('hello_from_func!')
	return hello

func = generator()
func()

>>> Hello_from_func!
```

внутри одних функций мы можем определять другие функции
когда у нас есть внутренняя и внешняя функция, где внутренняя использует параметры внешней функции, то такую вложенность называют замыканием
Замыкания – вложенные функции, ссылающиеся на переменные, объявленные вне определения этой функции, и не являющиеся её параметрами.

не оч ясный, но пример
```python
def generator_square_polynom(a, b, c):
    def square_polynom(x):
        return a * x**2 + b * x + c

    return square_polynom

f = generator_square_polynom(a=1, b=2, c=1)
g = generator_square_polynom(a=2, b=0, c=-3)
h = generator_square_polynom(a=-3, b=-10, c=50)

print(f(1))
print(g(2))
print(h(-1))

>>> 4
>>> 5
>>> 57
```
иными словами, мы построили функции 
- f(x)=x2+2x+1 
- g(x)=2x2−3
- h(x)=−3x2−10x+50
## Примечания
1. `.sort()` и `sorted()` кроме необязательного аргумента `key` принимают также и аргумент `reverse`, который по умолчанию имеет значение `False`, что соотв сортировке по возрастанию. True - сортировка по убыванию
2. Сортировка при помощи функции `sorted()` и списочного метода `sort()` [стабильна](https://ru.wikipedia.org/wiki/%D0%A3%D1%81%D1%82%D0%BE%D0%B9%D1%87%D0%B8%D0%B2%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0), то есть гарантирует неизменность взаиморасположения равных между собой элементов. (если мы явно указываем способ сравнения, то даже при неправильной расстановке вторых и последующих эл-тов сохранится их расположение). тут пример неплохо показывает
```python
	def comparator(item):
	    return item[0]
	
	
	data = [('red', 1), ('blue', 2), ('green', 5), ('blue', 1)]
	data.sort(key=comparator)   # сортируем по первому полю
	
	print(data)
	
	>>> [('blue', 2), ('blue', 1), ('green', 5), ('red', 1)]
```
обращаем внимание, что кортежи `('blue', 2), ('blue', 1)` не поменяли своего положения друг относительно друга (не происходило сравнения по вторым эл-там, т.к мы указали иной порядок)
3. функции `max, min` возвращают ==первый== макс/мин эл-ты, если таковых несколько
4. важно понимать разницу в записях `print(input())` и `print(input)`
	1. `print(input())` - запросит записать значение и сразу его выведет (сначала внутренняя функция, потом внешняя)
	2. `print(input)` - выдаст нам текстовое представление функции: строку `built-in function input` , что поясняет нам, что мы не вызвали функцию, а лишь вызвали ее ==название==
![[python-error.png]]
если чет подзабыл, чекни глоссарий: https://stepik.org/lesson/508939/step/17?auth=login&unit=501049

# Функции высшего порядка
## Содержание
1. Функции высшего порядка
2. Самописные функции `map()`, `filter()`, `reduce()`
## Функции высшего порядка
Функции, что принимают/возвращают другие функции - функции высшего порядка
Реализуем простейшую функцию высшего порядка
```python
def high_order_func(func):
	return func(3)
# принимается функция


def double(x):
	return x * 2
# обычная функция первого порядка


print(high_order_func(double))

>>> 6
```
функции первого порядка принимают и возвращают "обычные" значения, а не функции
функции высшего порядка принимают и возвращают другие функции

## Функции высшего порядка для обработки набора данных
Часто функции высшего порядка используются для обработки набора данных. Рассмотрим три важные функции высшего порядка: 
- `map()`
- `filter()`
- `reduce()`
в пайтоне эти функции уже реализованы, но лучше разобраться

## Функция `map()`
при работе со списками часто требуется применить одно и то же преобразование к каждому эл-ту. можно написать цикл, например так:
```python
def f(x):
	return x**2

old_list = [1, 2, 3, 4]
new_list = []

for item in old_list:
	new_item = f(item)
	new_list.append(new_item)

print(old_list)
print(new_list)

>>> [1, 2, 3, 4]
>>> [1, 4, 9, 16]
```

обобщим, сделав функцию параметром
```python
def map(func, items):
	result = []
	for item in items:
		new_item = func(item)
		result.append(new_item)

	return result
```
теперь можем совершать преобразования, используя функцию высшего порядка `map()`
```python
def square(x):
	return x**2


numbers = [1, 2, 3]

strings = map(str, numbers)
squares = map(square, numbers)

print(strings)
print(squares)

>>> ['1', '2', '3']
>>> [1, 4, 9]
```
map - отобразить. (из математики множеств)
можно и через списочное выражение (генератор)
``` python
numers = [1, 2, 3]

numbers1 = [str(i) for i in numbers]
numbers2 = [i**2 for i in numbers]

print(numbers1)
print(numbers2)

>>> ['1', '2', '3']
>>> [1, 4, 9]
```
полная аналогия с функцией `map()`
## Цепочки преобразований
можно делать цепочки преобразований с несколькими `map()`
```python
numbers = ['-1', '20', '3', '-94', '65', '6', '-970', '8']
new_nums = map(abs, map(int, numbers))

print(new_nums)

>>> [1, 20, 3, 94, 65, 6, 970, 8]
```
все легко
## Функция `filter()
популярная функция для работы со списками. отбор эл-тов списка по критериям
>Функция-критерий, которая возвращает значения `True` или `False`, называется предикатом  

реализация:
```python
def filter(func, items):
	result = []
	for item in items:
		if func(item):  # if func == True
			result.append(item)
	return result
	
# ну тут все вообще легко
def is_greater10(num):
	return num > 10


numbers = [1, 2, 34, 56]

large_numbers = filter(is_greater10, numbers)

>>> [34, 56]
```
вообще крутяк
я так понимаю, здесь и цепочки можно делать
## Функция `reduce()`
функции map() и filter() работали независимо с каждым отельным эл-том. но бывает и так (я просто вставлю этот капец)
![[Pasted image 20250820083301.png]]
примеры агрегации - сумма всех эл-тов списка или их произведение
1 + 2 + 3 мб представлено так:
(((0 + 1) + 2) + 3)
0 - аккумулятор, отправная точка. если список пуст, то 0 - результат
1 - аккумулятор для произведения
обобщим
```python
def operation(x, y):
	return x + y


def reduce(operation, items, initial_value):
	acc = initial_value
	for item in items:
		acc = operation(acc, item)
	return acc
```
пример:
```python
def add(x, y): 
	return x + y

nums = [1, 2, 3]
total = reduce(add, nums)
print(total)

>>> 6
```
кароче `reduce()` пробегается по всем эл-там и выполняет с ними определенную операцию
## Примечания
каждая из этих функций имеет меньшую мощность, чем цикл `for` (хз че значит)
такие функции - часть функционального кода, потому не используют просто циклы. каждая функция делает лишь одно действие, потому в коде проще ориентироваться. фильтр - отбрасывает часть, фильтруя, не меняя эл-ты, мап - преобразует эл-ты, не меняя кол-во
в матеше есть функция левой свертки (left fold), что сворачивает список слева. если функция ассоциативна, то результат аналогичен правой свертке (right fold)

**✅ Агрегация результата** — формирование одного результирующего значения при комбинации элементов с использованием аргумента-аккумулятора.
по-человечески: формирование результата путем применения определенного действия с эл-тами 
# Встроенные функции map(), filter(), reduce()
## Содержание
1. Встроенные функции `map()`, `filter()`, `reduce()`
2. Модуль `operator`
## Встроенные функции map(), filter(), reduce()
В пайтоне уже есть эти реализованные функции, что намного удобнее
## Встроенная функция `map()`
> **✅ Встроенная функция `map(func, iterable, *iterables)`** возвращает итератор с результатами применения функции `func` к элементам итерируемого объекта `iterable`. Если передано несколько итерируемых объектов, в функцию `func` будут передаваться сразу несколько элементов, расположенных на одинаковых позициях.
синтаксис функции `map()`: `map(func, iterable, iterables*)`
```python
# про 3 аргумент функции
from operator import add

result = list(map(add, 'abc', '1234'))
print(result)

>>> ['a1', 'b2', 'c3']
# Если в последовательностях разное количество элементов, то последовательность с минимальным количеством элементов становится ограничителем
```
отличие от нашей версии: встроенная умеет принимать сразу несколько последовательностей
в func передается текущий эл-т последовательности
внутри func нужно вернуть новое значение
пример:
```python
def increase(num):
	return num + 7


numbers = [1, 2, 3]
new_nums = map(increase,numbers)
print(new_nums)

>>> <map object at 0x...>
```
вернуло не список, а специальный объект - итератор. его можно перебирать(итерировать) циклом `for`
```python
def increase(num):
	return num + 7


nums = [1, 2, 3]
new_nums = map(increase, nums)
for num in new_nums:
	print(num)
>>> 1
>>> 2
>>> 3

	# чтобы получить список:
new_nums = list(map(increase, nums))
print(new_nums)
>>> [1, 2, 3]
```
 так преобразуется итератор в список
 про несколько последовательностей: они последовательно будут переданы в функцию func из аргументов, пример:
```python
def func(a, b, c):
	return a + b * c

nums1 = [1, 2, 3]
nums2 = [4, 5, 6]
nums3 = [7, 8, 9]

new_nums = list(map(func, nums1, nums2, nums3))
print(new_nums)
>>> [7, 34, 79]
```
если в одно из списков эл-тов меньше, то ограничением будет список с наим числом эл-тов
```python
def func(a, b, c):
	return a + b + c


a = [1, 2, 3]
b = [1, 2, 3, 4]
c = [1, 2]
...
>>> [3, 6] 
```
встроенная функция `map()` реализована очень гибко. можем использовать списки, словари, кортежи, множества, строки
встроенная функция `round(x, n=0)` принимает 2 аргумента. x - число для округления, n - кол-во знаков после запятой для округления. по умолчанию до 0 знаков
## Встроенная функция `filter()`
> **✅ Встроенная функция `filter(func, iterable)`** возвращает итератор, содержащий только те элементы итерируемого объекта `iterable`, для которых функция `func` возвращает `True`. Если вместо `func` указать `None`, каждый элемент будет проверен на соответствие значению `True`.

встроенная функция `filter()` имеет следующий синтаксис: `filter(func, iterable)`
отличие от нашей реализации: может принимать любой итерируемый объект
для примера удалим все отриц значения из списка
```python
def func(x):
	return x > 0


numbers = [-1, 2, -3, 4, 0, -20, 10]
new_nums = list(filter(func, nums))
print(new_nums)
>>> [2, 4, 10]
```
`filter()` как и `map()` возвращает не список, а специальный итерируемый объект
итераторы либо перебираются в цикле `for`, либо преобразуются в список
в качестве первого аргумента `func` можно передать `None`. тогда каждый эл-т будет проверен как `True`.
```python
true_values = filter(None, [1, 0, 10, '', None, [], [1, 2, 3], ()])

for value in true_values:
    print(value)
>>> 1
>>> 10
>>> [1, 2, 3]
```
вспоминай, что является тру, а что фолс
![[Pasted image 20250820122250.png]]

## Функция `reduce()`
>**✅ Функция** **`reduce(func, iterable, initializer=None)`** из модуля `functools` последовательно применяет функцию `func` к элементам итерируемого объекта `iterable` слева направо, сводя его к одному значению. Начальное значение задаётся через `initializer`. Если начальное значение не установлено, то в его качестве используется первое значение `iterable`.

для использования этой функции надо импортировать библиотеку `functools`
синтаксис: reduce(func, iterable, initializer=None)
если начальное значение не поставить, то им будет первое значение iterable
```python
from functools import reduce

def func(a,b):
	return a + b


nums = [1, 2, 3]
total = reduce(func, nums, 0)
print(total)
>>> 6

# или
total = reduce(func, nums)
# тогда начальным эл-том будет первое значение nums
```
## Модуль `operator`
чтобы не писать каждый раз стандартные мат функции типа произведения или суммы, можно использовать этот модуль
```python
def sum_func(a, b):
	return a + b

# или же
from operator import add
add(a, b)
```
таблица функций из этого модуля

| **Операция**          | **Синтаксис** | **Функция**                      |
| --------------------- | ------------- | -------------------------------- |
| Addition              | `a + b`       | `add(a, b)`                      |
| Containment Test      | `obj in seq`  | `contains(seq, obj)`             |
| Division              | `a / b`       | `truediv(a, b)`                  |
| Division              | `a // b`      | `floordiv(a, b)`                 |
| Exponentiation        | `a ** b`      | `pow(a, b)`                      |
| Modulo                | `a % b`       | `mod(a, b)`                      |
| Multiplication        | `a * b`       | `mul(a, b)`                      |
| Negation (Arithmetic) | `-a`          | `neg(a)`                         |
| Subtraction           | `a - b`       | `sub(a, b)`                      |
| Ordering              | `a < b`       | `lt(a, b)` **G**reater-**T**han  |
| Ordering              | `a <= b`      | `le(a, b)` **L**ess-**E**qual    |
| Equality              | `a == b`      | `eq(a, b)` **EQ**ual             |
| Difference            | `a != b`      | `ne(a, b)` **N**ot **E**qual     |
| Ordering              | `a >= b`      | `ge(a, b)` **G**reater-**E**qual |
| Ordering              | `a > b`       | `gt(a, b)` **L**ess-**T**han     |

импорт всех функций сразу
```python
from operator import *
```
этот модуль реализован на языке С, т.к эти функции работают куда быстрее, чем самописные в пайтон
## Примечания
итераторы - важная концепция пайтона
их можно:
- обойти циклом `for`
- преобразовать в список или кортеж (`list()`, `tuple()`)
- итератор можно распаковать с помощью `*`
	```python
	nums = [1, -2, 3, -4]
	map_obj = map(abs, nums)
	print(*map_obj)
	>>> 1 2 3 4
    ```
можно использовать строковые методы
```python
pets = ['alfred', 'tabitha', 'william', 'arla']
chars = ['x', 'y', '2', '3', 'a']
 
uppered_pets = list(map(str.upper, pets))
capitalized_pets = list(map(str.capitalize, pets))
only_letters = list(filter(str.isalpha, chars))

print(uppered_pets)
print(capitalized_pets)
print(only_letters)

>>> ['ALFRED', 'TABITHA', 'WILLIAM', 'ARLA']
>>> ['Alfred', 'Tabitha', 'William', 'Arla']
>>> ['x', 'y', 'a']
```
аналогично получаются методы других типов данных
подробнее про модуль `operator` в документации
https://docs.python.org/3/library/operator.html

# Анонимные функции
## Содержание
1. Определение анонимных функций
2. Условный оператор в теле анонимной функции
3. Передача аргументов в анонимную функцию
4. Ограничения анонимных функций
## Анонимные функции
Можно создавать функции с уникальными именами, но иногда имя не требуется, особенно, если функция используется всего один раз
можно создать анонимную функцию - однострочная функция с использованием оператора `lambda`. Это и есть анонимные функции или лямбда-функции. в них есть тело, но нет имени
формат лямбда-функций: `lambda список_параметров: выражение`
здесь параметры не нужно заключать в скобки
приведем пример двух идентичных функций:
```python
def standard_func(x):
	return x * 2

lambda_func = lambda x: x * 2

print(standard_func(7))
print(lambda_func(7))
>>> 14
>>> 14
```
рассмотрим еще примеры
```python
f1 = lambda: 10 + 20  # без параметров
f2 = lambda x, y: x + y
f3 = lambda x, y, z: x + y + z

print(f1, f2(1, 2), f3(1, 2, 3), sep='\n')

>>> 30
>>> 3
>>> 6
```
Использование анонимных функций оправдано, когда:
- функция используется один раз
- передается функция в качестве аргумента другим функциям 
- возвращение функции в качестве результата другой функции (хз)
## Однократное использование функции
 для специальных сортировок мы делали специальные функции-компараторы
 ```python
def compare_by_second(point):
    return point[1]


def compare_by_sum(point):
    return point[0] + point[1]


points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]

print(sorted(points, key=compare_by_second))   # сортируем по второму значению кортежа
print(sorted(points, key=compare_by_sum))      # сортируем по сумме кортежа
```
очев, что вне этого сравнения эта функция не нужна, заменим на анонимные функции
анонимные функции:

```python
points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]

print(sorted(points, key=lambda index: index[1]))
print(sorted(points, key=lambda index: index[0] + index[1]))
```
index - можно заменить на другое название
## Передача анонимных функций в качестве аргументов другим функциям
функции высшего порядка идеально покажут работу анонимных функций
``` python
from functools import reduce

nums = [1, -2, 3, -4]

map_list = list(map(lambda x: str(x), nums))
filter_list = list(filter(lambda x: x > 0, nums))
reduce_list = reduce(lambda x, y: x + y, nums, 0)

print(map_list, filter_list, reduce_list, sep='\n')

>>> ['1', '-2', '3', '-4']
>>> [1, 3]
>>> -2
```

```python
# map() примеры
numbers = [1, 2, 3, 4, 5, 6]

new_numbers1 = list(map(lambda x: x+1, numbers))      #  увеличиваем на 1
new_numbers2 = list(map(lambda x: x*2, numbers))      #  удваиваем
new_numbers3 = list(map(lambda x: x**2, numbers))     #  возводим в квадрат

print(new_numbers1)
print(new_numbers2)
print(new_numbers3)

>>> [2, 3, 4, 5, 6, 7]
>>> [2, 4, 6, 8, 10, 12]
>>> [1, 4, 9, 16, 25, 36]


strings = ['a', 'b', 'c', 'd', 'e']
numbers = [3, 2, 1, 4, 5]

new_strings = list(map(lambda x, y: x*y, strings, numbers))

print(new_strings)

>>> ['aaa', 'bb', 'c', 'dddd', 'eeeee']
```


```python
# filter() прмеры
numbers = [-1, 2, -3, 4, 0, -20, 10, 30, -40, 50, 100, 90]

positive_numbers = list(filter(lambda x: x > 0, numbers))      #  положительные числа
large_numbers = list(filter(lambda x: x > 50, numbers))        #  числа, большие 50
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))     #  четные числа

print(positive_numbers)
print(large_numbers)
print(even_numbers)

>>> [2, 4, 10, 30, 50, 100, 90]
>>> [100, 90]
>>> [2, 4, 0, -20, 10, 30, -40, 50, 100, 90]


words = ['python', 'stepik', 'beegeek', 'iq-option']

new_words1 = list(filter(lambda w: len(w) > 6, words))    #  слова длиною больше 6 символов
new_words2 = list(filter(lambda w: 'e' in w, words))      #  слова содержащие букву e

print(new_words1)
print(new_words2)

>>> ['beegeek', 'iq-option']
>>> ['stepik', 'beegeek']
```


```python
# reduce() примеры
from functools import reduce

words = ['python', 'stepik', 'beegeek', 'iq-option']
numbers = [1, 2, 3, 4, 5, 6]

summa = reduce(lambda x, y: x + y, numbers, 0)
product = reduce(lambda x, y: x * y, numbers, 1)
sentence = reduce(lambda x, y: x + ' loves ' + y, words, 'Everyone')

print(summa)
print(product)
print(sentence)

>>> 21
>>> 720
>>> Everyone loves python loves stepik loves beegeek loves iq-option
```
## Возвращение функции в качестве результата другой функции
анонимные функции могут возвращать результат работы других функций
анонимные функции являются замыканиями, она запоминает значения переменных из внешнего окружения, когда находится в теле другой функции

Приведенный ниже код по значениям a,b,c строит и возвращает квадратный трехчлен:

```python
def generator_square_polynom(a, b, c):
    def square_polynom(x):
        return a*x**2 + b*x + c
    return square_polynom
```

Такой код можно переписать так:

```python
def generator_square_polynom(a, b, c):
    return lambda x: a*x**2 + b*x + c
```
для лучшего понимания повтори этот код
```python
def generator_square_polynom(a, b, c):
    def square_polynom(x):
        return a * x**2 + b * x + c

    return square_polynom

f = generator_square_polynom(a=1, b=2, c=1)
g = generator_square_polynom(a=2, b=0, c=-3)
h = generator_square_polynom(a=-3, b=-10, c=50)

print(f(1))
print(g(2))
print(h(-1))

>>> 4
>>> 5
>>> 57
```
более менее окей
## Условный оператор в теле анонимной функции
в теле анонимных функций не выйдет использовать многострочные условия типа циклов, но можно использовать тернарный условный оператор (блок условий в строчку)
``` python
nums = [1, 2, 3, 4]

result = list(map(lambda x: 'чёт' if x%2==0 else 'нечёт'))

print(result)

>>> ['нечёт', 'чёт', 'нечёт', 'чёт']
```
общий вид тернарного оператора в теле анонимной функции выглядит так
``` python
значение1 if условие else значение2
```
## Передача аргументов в анонимную функцию
как и обычные самописные функции, lambda поддерживает все способы передачи аргументов
- позиционные
- именованные
- переменный список позиционных - `*args`
- переменный список именованных - `**kwargs`
- обязательные аргументы - `*`
```python
f1 = lambda x, y, z: x + y + z
f2 = lambda x, y, z=3: x + y + z
f3 = lambda *args: sum(args)
f4 = lambda **kwargs: sum(kwargs.values())
f5 = lambda x, *, y=0, z=0: x + y + z


print(f1(1, 2, 3))
print(f2(1, 2))
print(f2(1, y=2))
print(f3(1, 2, 3, 4, 5))
print(f4(one=1, two=2, three=3))
print(f5(1))
print(f5(1, y=2, z=3))

>>> 6
>>> 6
>>> 6
>>> 15
>>> 6
>>> 1
>>> 6
```
## Ограничения анонимных функций
- может содержать только выражение, не может содержать операторы (?)
- операторы типа `return`, `pass`, `assert`, `raise` вызовут исключение `SyntaxError`
- может быть немедленно вызвана
- пишется в одну строку
## Примечания
можно делать вот такую приколюху:
```python
print((lambda х, у: х + у)(5, 10))     # 5 + 10
print(1 + (lambda x: x*5)(10) + 2)     # 1 + 50 + 2

>>> 15
>>> 53
```
на практике это редкое явление
в пайтоне лямбда выражение - лишь сокращение записи
``` python
f = lambda x: x + 1


print(f(3))
print(type(f))

>>> 4
>>> <class 'function'>
```
анонимные функции имеют тот же тип, что и обычные функции
анон функции очень часто используют вместе со встроенными функциями `map(), filter(), reduce(), sorted(), max(), min()` и тд
пример того, как делать не надо: анон функция внутри `filter()` передает эл-ты, а лямбда ничего не принимает
```python
primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
result = list(filter(lambda: True, primes))
print(result)
```

- в виде объявления сами являются выражениями
- могут иметь *args и **kwargs
- являются замыканиями (могут замыкать переменные из внешнего контекста)
- состоят из одного выражения (возможно, составного)
```python
funcs = [lambda x: x ** 0.5, lambda x: x ** 2, lambda x: x ** 3]
print(funcs[1](9))
>>> 81
```

# Встроенные функции any(), all(), zip(), enumerate()
## Содержание
1. Функция `all()`
2. Функция `any()`
3. Функция `enumerate()`
4. Функция `zip()`
## Функция `all()`
при работе с коллекциями часто приходится проверять, выполняется ли одно условие сразу для всех эл-тов или хотя бы для одного. `any()` и `all()` именно для этого
`all()` возвращает `True`, если все эл-ты последовательности приводятся к `True`. `False` в противном случае
синтаксис:
`all(iterable)`
`iterable` - любая коллекция, которую можно итерировать
- список
- строка
- кортеж
- мн-во
- словарь
```python
print(all([True, True, True]))     #  возвращает True, так как все значения списка равны True
print(all([True, True, False]))    #  возвращает False, так как не все значения списка равны True

>>> True
>>> False
```
к `False` приводятся все следующие значения:
- `None` и `False`
- нули всех типов данных `0`, `0.0`, `0j`, `Decimal(0)`, `Fraction(0, 1)`
- пустые коллекции `''`, `()`, `[]`, `{}`, `set()`, `range(0)`.
в словарях идет проверка ключей на соответствие значению `True` , а не значений
если итерируемый объект пустой, то вернется `True`
```python
print(all([]))          #  передаем пустой список
print(all(()))          #  передаем пустой кортеж
print(all(''))          #  передаем пустую строку
print(all([[], []]))    #  передаем список, содержащий пустые списки

>>> True
>>> True
>>> True
>>> False

dict1 = {0: 'Zero', 1: 'One', 2: 'Two'}
dict2 = {'Zero': 0, 'One': 1, 'Two': 2}

print(all(dict1))
print(all(dict2))

>>> False
>>> True
```
если переданный итерируемый объект пустой, то функция `all()` выведет `True`
``` python
print(all([]))          #  передаем пустой список
print(all(()))          #  передаем пустой кортеж
print(all(''))          #  передаем пустую строку
print(all([[], []]))    #  передаем список, содержащий пустые списки

>>> True
>>> True
>>> True
>>> False
```
## Функция `any()`
функция `any()` возвращает `True`, если хотя бы один эл-т возвращает `True`, иначе `False`
синтаксис:
`any(iterable)`, где `iterable` - любой итерируемый объект
- список;
- кортеж;
- строка;
- множество;
- словарь и т.д.
```python
print(any([False, True, False]))       #  возвращает True, так как есть хотя бы один элемент, равный True
print(any([False, False, False]))      #  возвращает False, так как нет элементов, равных True
>>> True
>>> False
```

```python
print(any([0, 0, 0]))
print(any([0, 1, 0]))
print(any([False, 0, 1]))
print(any(['', [], 'green']))
print(any({0j, 3+4j, 0.0}))

>>> False
>>> True
>>> True
>>> True
>>> True
```
если передать пустой объект в `any()`, то вернет `False`
```python
print(any([]))          #  передаем пустой список
print(any(()))          #  передаем пустой кортеж
print(any(''))          #  передаем пустую строку
print(any([[], []]))    #  передаем список, содержащий пустые списки

>>> False
>>> False
>>> False
>>> False
```
## Функции `all()` и `any()` в связке с функцией `map()`
эти функции могут быть полезны в сочетании с функцией `map()`
этот код проверяет, все ли эл-ты списка `numbers` больше 10
```python
numbers = [17, 90, 78, 56, 231, 45, 5, 89, 91, 11, 19]

result = all(map(lambda x: True if x > 10 else False, numbers))

if result:
    print('Все числа больше 10')
else:
    print('Хотя бы одно число меньше или равно 10')

>>> Хотя бы одно число меньше или равно 10
# тк тут есть числа меньше или равны 10 (число 5)
```
можно упростить 
``` python
result = all(map(lambda x: x > 10, numbers))
```
аналог с `any()`
```python
numbers = [17, 91, 78, 55, 231, 45, 5, 89, 99, 11, 19]

result = any(map(lambda x: x % 2 == 0, numbers))

if result:
    print('Хотя бы одно число четное')
else:
    print('Все числа нечетные')

>>> Хотя бы одно число четное  # тк есть число 78
```
## Функция enumerate()
функция возвращает кортеж из индекса эл-та и самого эл-та
синтаксис:
`emumerate(iterable, start)`, где `iterable` - любой итерируемый объект
- список;
- кортеж;
- строка;
- множество;
- словарь и т.д.
с помощью необязательного параметра `start` можно указать начальное значение индекса. по умолчанию это значение = 0, т.е с самого первого эл-та
```python
colors = ['red', 'green', 'blue']

for pair in enumerate(colors):
    print(pair)

>>> (0, 'red')
>>> (1, 'green')
>>> (2, 'blue')
```
если надо начать отсчет с другого числа, то явно его указываем в параметре `start`
```python
colors = ['red', 'green', 'blue']

for pair in enumerate(colors, 100):
    print(pair)

>>> (100, 'red')
>>> (101, 'green')
>>> (102, 'blue')
```
функция `enumerate()` возвращает не список, а итератор - специальный объект
можно перебрать его циклом `for`, т.е итерировать. 
можно преобразовать итератор в список функцией `list()`
```python
colors = ['red', 'green', 'blue']

pairs = enumerate(colors)

print(pairs)
print(list(pairs))

>>> <enumerate object at 0x...>
>>> [(0, 'red'), (1, 'green'), (2, 'blue')]
```
можем произвести распаковку кортежей при итерировании при помощи цикла `for`
```python
colors = ['red', 'green', 'blue']
for index, item in enumerate(colors):
    print(index, item)

# аналогично
colors = ['red', 'green', 'blue']
for i in range(len(colors)):
    print(i, colors[i])

>>> 0 red
>>> 1 green
>>> 2 blue
```
## Функция `zip()`
эта функция объединяет отдельные эл-ты из каждой переданной последовательности в кортежи
синтаксис:
`zip(*iterables)`, где `iterables` - любой итерируемый объект
- список;
- кортеж;
- строка;
- множество;
- словарь и т.д.
![[Unxxxtitled.png]]
```python
numbers = [1, 2, 3]
words = ['one', 'two', 'three']

for pair in zip(numbers, words):
    print(pair)

>>> (1, 'one')
>>> (2, 'two')
>>> (3, 'three')
```
функция `zip()` возвращает не список, а итератор - специальный объект
можно перебрать его циклом `for`, т.е итерировать. 
можно преобразовать итератор в список функцией `list()`
```python
numbers = [1, 2, 3]
words = ['one', 'two', 'three']

result = zip(numbers, words)

print(result)
print(list(result))

>>> <zip object at 0x...>
>>> [(1, 'one'), (2, 'two'), (3, 'three')]
```
функции `zip()` можно передавать сколько угодно итерируемых объектов
пример из 3 эл-тов
```python
numbers = [1, 2, 3]
words = ['one', 'two', 'three']
romans = ['I', 'II', 'III']

result = zip(numbers, words, romans)
print(list(result))

>>> [(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', 'III')]
```
можно даже передать всего 1 эл-т, вывод будет интересный:
```python
numbers = [1, 2, 3]
result = zip(numbers)
print(list(result))

>>> [(1,), (2,), (3,)]  # реально такой вывод, необычно
```
если передать объекты разной длины, то учитываться будет только наименьшая из длин 
```python
numbers = [1, 2, 3, 4]
words = ['one', 'two']
romans = ['I', 'II', 'III']

result = zip(numbers, words, romans)
print(list(result))

>>> [(1, 'one', 'I'), (2, 'two', 'II')]
```
## Частые сценарии использования функции zip()
1 сценарий:
для создания словарей, когда ключи и значения находятся в разных списках
```python
keys = ['name', 'age', 'gender']
values = ['Timur', 28, 'male']

info = dict(zip(keys, values))
print(info)

>>> {'name': 'Timur', 'age': 28, 'gender': 'male'}
```
2 сценарий:
удобно для одновременного (параллельного) итерирования сразу по нескольким коллекциям
```python
name = ['Timur', 'Ruslan', 'Rustam']
age = [28, 21, 19]

for x, y in zip(name, age):
    print(x, y)

>>> Timur 28
>>> Ruslan 21
>>> Rustam 19
```
## Примечания
- *примерная* реализация функций `all()` и `any()`
```python
def all(iterable):
    for item in iterable:
       if not item:
           return False
    return True

def any(iterable):
    for item in iterable:
        if item:
            return True
    return False
```
- можем одновременно использовать `zip()` и `enumerate()`:
```python
list1 = ['a1', 'a2', 'a3']
list2 = ['b1', 'b2', 'b3']

for index, (item1, item2) in enumerate(zip(list1, list2)):
    print(index, item1, item2)

>>> 0 a1 b1
>>> 1 a2 b2
>>> 2 a3 b3
```
- с помощью zip() можно очень просто транспонировать матрицу:
```python
matrix = [[1, 2, 3, 4], 
          [5, 6, 7, 8], 
          [9, 10, 11, 12]]

new_matrix = list(zip(*matrix))
[print(*row) for row in new_matrix]

>>> 1 5 9
>>> 2 6 10
>>> 3 7 11
>>> 4 8 12
```
только вот matrix — это список списков, а new_matrix — список кортежей.  
Получить на выходе такой же список списков можно вот так: `new_matrix = list(map(list, zip(*matrix)))`
- реализация `zip()` и `enumerate()`
```python
def zip(*iterables):
    length = min(map(len, iterables))
    result = []
    for index in range(length):
        new_item = tuple(map(lambda item: item[index], iterables))
        result.append(new_item)
    return result

def enumerate(iterable, start=0):
    result = []
    for index in range(len(iterable)):
        new_item = (index + start, iterable[index])
        result.append(new_item)
    return result
```
![[Pasted image 20250830104524.png]]


# Отчет по реализации системы логирования

## 1. Устройство параметризуемого декоратора

Декоратор `@logger` реализован как функция, принимающая параметры:

```python
def logger(func=None, *, handle=sys.stdout) -> Callable:
```

**Ключевые особенности:**
- Поддерживает три варианта вызова:
  - `@logger` (без скобок)
  - `@logger()` (скобки без параметров)
  - `@logger(handle=...)` (с указанием потока вывода)
- Принимает `handle` — объект для логирования (sys.stdout, файл, StringIO, logging.Logger)
- Использует `functools.wraps` для сохранения метаданных оригинальной функции
- Автоматически определяет тип `handle` и выбирает способ записи

**Логика работы:**
1. Логирует вызов функции с аргументами
2. Выполняет обернутую функцию
3. При успехе — логирует результат
4. При ошибке — логирует с уровнем в зависимости от типа исключения:
   - `WARNING` для отрицательного дискриминанта
   - `CRITICAL` для уравнения с a=b=0
   - `ERROR` для остальных исключений
5. Пробрасывает исключение дальше

## 2. Функция get_currencies (без логирования)

**Назначение:** Получение курсов валют с API ЦБ РФ

**Параметры:**
```python
def get_currencies(currency_codes: list, url: str = "https://www.cbr-xml-daily.ru/daily_json.js", test_response: dict = None) -> dict:
```

**Основная логика:**
1. **Получение данных:**
   - Если передан `test_response` — используется для тестирования
   - Иначе — HTTP-запрос к API с обработкой сетевых ошибок

2. **Валидация ответа:**
   - Проверка наличия ключа `"Valute"`
   - Поиск кодов валют в ответе
   - Проверка типа значений курсов (должны быть числа)

3. **Обработка ошибок:**
   - `ConnectionError` — проблемы с сетью/доступом
   - `ValueError` — некорректный JSON в ответе
   - `KeyError` — отсутствует валюта или ключ `Valute`
   - `TypeError` — неверный тип значения курса

## 3. Демонстрация на примере квадратного уравнения

**Функция solve_quadratic:**
```python
def solve_quadratic(a, b, c):
```

### Четыре сценария логирования:

1. **INFO — успешное решение (два корня):**
   ```python
   solve_quadratic(1, -3, 2) → [2.0, 1.0]
   ```
   Логи:
   
   `[INFO] Calling solve_quadratic(1, -3, 2)`

   `[INFO] solve_quadratic returned [2.0, 1.0]`

3. **WARNING — отрицательный дискриминант:**
   ```python
   solve_quadratic(1, 0, 1) → ValueError
   ```
   Логи: `[WARNING] solve_quadratic raised ValueError: Дискриминант отрицательный: D=-4`

4. **ERROR — некорректные данные:**
   ```python
   solve_quadratic("abc", 1, 2) → TypeError
   ```
   Логи: `[ERROR] solve_quadratic raised TypeError: Коэффициент 'a' должен быть числом`

5. **CRITICAL — невозможная ситуация:**
   ```python
   solve_quadratic(0, 0, 5) → ValueError
   ```
   Логи: `[CRITICAL] solve_quadratic raised ValueError: Оба коэффициента a и b равны нулю...`

## 4. Тестирование системы

### Тесты декоратора (test_decor.py):
- **Успешный вызов:** Проверка INFO-логирования с аргументами и результатом
- **WARNING-логирование:** Отрицательный дискриминант → [WARNING] и проброс исключения
- **CRITICAL-логирование:** a=0, b=0 → [CRITICAL] и проброс исключения
- **ERROR-логирование:** Произвольное исключение → [ERROR] и проброс

### Тесты функции get_currencies (test_get_currencies.py):
- **Валидные данные:** Корректный запрос → возврат словаря курсов
- **Пустой список:** Возврат пустого словаря
- **Несуществующая валюта:** KeyError
- **Отсутствие ключа Valute:** KeyError
- **Некорректный JSON:** ValueError
- **Неправильный тип курса:** TypeError
- **Ошибка соединения:** ConnectionError (интеграционный тест)

### Тесты с StringIO:
**Использование в тестах:**

ПРИМЕР ИСПОЛЬЗОВАНИЯ ```StringIO``` ДЛЯ ТЕСТИРОВАНИЯ ```logger```

```python
def setUp(self):
    self.stream = io.StringIO()
    
@logger(handle=self.stream)
def test_func():
    # тестовая функция

# Проверка содержимого логов
logs = self.stream.getvalue()
self.assertIn("[INFO]", logs)
```

**Преимущества:**
- Изоляция тестов от реальных потоков вывода
- Возможность проверки точного содержимого логов
- Отсутствие побочных эффектов (записи в файлы/консоль)

### Тесты обработки исключений:
Все тесты используют контекстный менеджер `assertRaises` для проверки корректности проброса исключений через декоратор и ```assertIn``` для проверки коректного вывода ошибки, что подтверждает сохранение оригинального поведения обернутых функций.
